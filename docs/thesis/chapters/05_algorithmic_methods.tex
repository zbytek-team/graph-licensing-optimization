\chapter{Metody algorytmiczne optymalizacji kosztów licencji}\label{chap:algorithms}

W rozdziale prezentuję wyłącznie te metody, które są wykorzystane w pracy i w repozytorium implementacyjnym. Każdy algorytm ma krótki opis celu, formalne założenia i złożoność, a przebieg podaję wyłącznie w pojedynczym, spójnym pseudokodzie po polsku (bez dublowania kroków w tekście). Niech $G=(V,E)$ będzie grafem nieskierowanym, $N(v)$ – sąsiedztwem wierzchołka $v$. Typy licencji $\mathcal{L}=\{\ell_1,\dots,\ell_T\}$ opisuję parametrami $(\min_\ell,\max_\ell,c_\ell)$.

\section{Dokładne algorytmy}

\subsection{Programowanie całkowitoliczbowe (ILP)}

Krótko: zmienne binarne $y_{i,\ell}$ (aktywacja grupy) i $x_{i,j,\ell}$ (przypisanie), cel $\min\sum_{i,\ell}c_\ell y_{i,\ell}$, pokrycie $\forall j:\sum_{i,\ell}x_{i,j,\ell}=1$, pojemność $\forall i,\ell:\sum_{j\in N(i)\cup\{i\}}x_{i,j,\ell}\in[\min_\ell y_{i,\ell},\max_\ell y_{i,\ell}]$, własny dostęp $x_{i,i,\ell}\ge y_{i,\ell}$. ILP zwraca optimum i służy jako punkt odniesienia.


\begin{algorithm}[H]
\caption{ILP – budowa i rozwiązanie modelu}
\label{alg:ilp}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, licencje $\mathcal{L}=\{(\min_\ell,\max_\ell,c_\ell)\}$
\Ensure optymalne grupy i koszt (gdy solver zakończy się optymalnie)
\State zdefiniuj binarne $y_{i,\ell}$ (aktywacja) i $x_{i,j,\ell}$ (przypisanie)
\State pokrycie: $\forall j\in V:\ \sum_{i\in V}\sum_{\ell\in\mathcal{L}} x_{i,j,\ell}=1$
\State pojemność: \(\forall i,\ell:\ \sum_{j\in N(i)\cup\{i\}} x_{i,j,\ell}\in[\min_\ell\,y_{i,\ell},\,\max_\ell\,y_{i,\ell}]\)
\State własny dostęp: \(\forall i,\ell:\ x_{i,i,\ell}\ge y_{i,\ell}\)
\State funkcja celu: \(\min\ \sum_{i,\ell} c_\ell\,y_{i,\ell}\)
\State rozwiąż ILP (CBC/Gurobi/CPLEX); zbuduj grupy z niezerowych \(x,y\)
\State \Return optymalne grupy i koszt
\end{algorithmic}
\end{algorithm}



\subsection{Algorytm naiwny}

Algorytm naiwny jest najbardziej bezpośrednim podejściem do problemu optymalnego przypisania licencji. Algorytm przeszukuje całą przestrzeń możliwych rozwiązań, gwarantując znalezienie globalnego optimum dla małych instancji. W przeciwieństwie do metod heurystycznych czy metaheurystycznych, które starają się jak najszybciej wygenerować dobre przybliżenie, algorytm naiwny nie stosuje żadnych uproszczeń ani aproksymacji – dla każdego możliwego podziału użytkowników na grupy licencyjne (oraz przypisania licencji indywidualnych) sprawdza warunki poprawności, oblicza łączny koszt i wybiera najlepsze rozwiązanie.

Takie wyczerpujące przeszukiwanie ma jednak swoją cenę: liczba rozwiązań rośnie nadwykładniczo wraz z rozmiarem grafu, dlatego w praktyce algorytm stosuje się wyłącznie do niewielkich sieci (w niniejszej pracy – maksymalnie $n\le10$ wierzchołków). Pomimo tej ograniczonej skalowalności, algorytm naiwny pełni kluczową rolę jako punkt odniesienia dla oceny jakości bardziej zaawansowanych metod. Jego główne zalety to prostota interpretacji, gwarancja optymalności oraz brak potrzeby dostrajania parametrów – wszystko, co jest potrzebne, to definicja dostępnych licencji i ograniczeń grupowych.

\paragraph{Główne założenia}
\begin{itemize}
  \item \emph{Rozłączność}: każdy wierzchołek należy do co najwyżej jednej grupy licencyjnej.
  \item \emph{Spójność}: każda grupa indukuje spójny podgraf w $G$.
  \item \emph{Pokrycie}: wszystkie wierzchołki muszą być objęte licencją (indywidualną lub grupową).
  \item \emph{Limit obliczeń}: w implementacji przyjmujemy $n\le10$ (ze względu na nadwykładniczy wzrost liczby rozwiązań).
\end{itemize}


\begin{algorithm}[H]
\caption{Algorytm naiwny – przegląd zupełny przestrzeni rozwiązań}
\label{alg:naive}
\begin{algorithmic}[1]
\Require graf \(G=(V,E)\), typy licencji \(\mathcal{L}\), opcjonalny limit \(n\le 10\)
\Ensure rozwiązanie optymalne (dla małych \(n\)) lub informacja o braku
\If{$|V|>10$} \State \Return \textit{przerwij – graf zbyt duży} \EndIf
\State wygeneruj wszystkie partycje \(\Pi\) zbioru \(V\)
\For{każdą partycję \(P=\{P_1,\dots,P_k\}\in\Pi\)}
  \State \(A\gets\emptyset\) \Comment lista dopuszczalnych przypisań dla bloków partycji
  \For{każdy blok \(P_i\) i licencję \(\ell\in\mathcal{L}\) z \(|P_i|\in[\min_\ell,\max_\ell]\)}
    \For{każdy \(v\in P_i\)}
      \If{$P_i\setminus\{v\}\subseteq N(v)$}
        \State dodaj krotkę \((\ell, v, P_i\setminus\{v\})\) do \(A\)
      \EndIf
    \EndFor
  \EndFor
  \State wygeneruj wszystkie kombinacje krotek z \(A\) (po jednej na każdy blok \(P_i\))
  \For{każde pełne przypisanie}
    \If{spełnia ograniczenia} \State policz koszt i zaktualizuj optimum \EndIf
  \EndFor
\EndFor
\If{nie znaleziono rozwiązań} \State przypisz wszystkim licencje indywidualne \EndIf
\State \Return najlepsze przypisanie
\end{algorithmic}
\end{algorithm}

\paragraph{Złożoność obliczeniowa}
Pełna przestrzeń dopuszczalnych przypisań odpowiada wszystkim rozłącznym, spójnym partycjom $V$ z grupami o rozmiarach w $[\min_\ell,\max_\ell]$. Górną granicę tej przestrzeni stanowi liczba Bella:
\[
B(n)=\text{liczba wszystkich partycji zbioru }V,\quad
B(n)\in\Theta\!\Bigl(\tfrac{1}{\sqrt n}\,\bigl(\tfrac{n}{\ln n}\bigr)^{\!n}\Bigr).
\]
Z powodu dodatkowych ograniczeń ($[\min_\ell,\max_\ell]$, spójność), liczba rozwiązań jest mniejsza od $B(n)$, ale nadal rośnie nadwykładniczo. Można zatem oszacować złożoność na:
\[
\mathcal{O}\bigl(c^n\bigr),
\]
gdzie stała $c>1$ zależy od maksymalnego stopnia wierzchołków, zakresu rozmiarów licencji i limitu $L$ odbiorców. Ze względu na tę złożoność algorytm jest praktyczny tylko dla $n\le10$ i pełni rolę algorytmu referencyjnego.  

\subsection{Programowanie dynamiczne na drzewach}
Dla grafów-drzew optymalne przypisanie licencji uzyskuję w czasie wielomianowym przez sklejanie wyników poddrzew; złożoność $O(|V|\cdot T \cdot 2^{d_{\max}})$, a dla stałego $d_{\max}$ praktycznie liniowa.

\begin{algorithm}[H]
\caption{Programowanie dynamiczne na drzewach – optimum dla drzew}
\label{alg:treedp}
\begin{algorithmic}[1]
\Require drzewo $T=(V,E)$, $\mathcal{L}$
\Ensure optymalny przydział dla klasy drzew
\State wybierz korzeń, rozwiązuj rekurencyjnie dla poddrzew
\State dla węzła $u$ rozważ licencje oraz ile dzieci dołączyć do grupy lidera, a resztę obsłuż w poddrzewach
\State zapamiętaj najlepszy koszt i sklej grupy z wyników dzieci
\State \Return rozwiązanie dla korzenia
\end{algorithmic}
\end{algorithm}

\section{Algorytmy przybliżone}

\subsection{Algorytm zachłanny}

Algorytmy zachłanne stanowią jedną z najprostszych i zarazem najczęściej wykorzystywanych technik przybliżonego rozwiązywania zadań kombinatorycznych, w tym problemów optymalizacyjnych na grafach. Ich kluczową ideą jest stopniowe, krokowe konstruowanie rozwiązania poprzez wybór w każdym kroku lokalnie „najlepszej” akcji – tej, która w danym momencie przynosi największą korzyść lub najmniejszy koszt. W przeciwieństwie do metod dokładnych, które eksplorują całą przestrzeń rozwiązań (jak algorytm naiwny czy ILP), heurystyki zachłanne stawiają na szybkość wykonania kosztem utraty gwarancji osiągnięcia optimum globalnego.

W kontekście dystrybucji licencji w sieciach społecznościowych nasz algorytm zachłanny wykorzystuje prostą metrykę efektywności: stosunek kosztu licencji do liczby użytkowników, którym może ona zapewnić dostęp. Zaczynamy od liderów o najwyższym stopniu w grafie – oni mają największy potencjał, by obsłużyć wielu sąsiadów. Dla każdego kandydata wybieramy typ licencji o odpowiedniej pojemności tak, aby maksymalizować liczbę nowych objętych użytkowników przy minimalnym wzroście całkowitego kosztu. W efekcie uzyskujemy szybki, deterministyczny algorytm, który w praktyce dobrze sprawdza się na dużych instancjach, gdzie metody dokładne są zbyt wolne.

Mimo braku formalnych gwarancji co do odległości od rozwiązania optymalnego, algorytm zachłanny ma kilka istotnych zalet. Po pierwsze, jego złożoność czasowa jest wielomianowa (w praktyce bliska $O(m\log n)$ dla grafu z $n$ wierzchołkami i $m$ krawędziami), co pozwala go stosować nawet w przypadku dużych sieci społecznościowych. Po drugie, implementacja jest prosta, a parametry – takie jak kryterium wyboru lidera czy sposobu sortowania dostępnych sąsiadów – można łatwo dostosować do specyfiki danych. Wreszcie, algorytm zachłanny może stanowić doskonałe rozwiązanie startowe (warm start) dla bardziej zaawansowanych metaheurystyk czy solwerów ILP.

Jako metoda przybliżona, algorytm zachłanny pełni ważną rolę w zestawie narzędzi do rozwiązywania problemu dystrybucji licencji: dostarcza wstępnej, szybko obliczalnej oceny kosztu optymalnego pokrycia grafu, którą można porównać z wynikiem algorytmu dokładnego lub wykorzystać jako punkt wyjścia do dalszej optymalizacji.

Heurystyka wybiera kolejnych właścicieli (preferując duży stopień) i dla każdego tworzy najkorzystniejszą kosztowo grupę w dopuszczalnym zakresie pojemności. Uzupełnia niepokryte węzły najmniejszymi grupami lub licencją 1. Złożoność w praktyce $O(nT + m\log n)$.

\begin{algorithm}[H]
\caption{Zachłanny – wybór grup o najlepszej efektywności kosztu}
\label{alg:greedy}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, rodzina licencji $\mathcal{L}$
\Ensure poprawny przydział grup minimalizujący heurystycznie koszt
\State $U \gets V$ \Comment zbiór wierzchołków niepokrytych
\State posortuj $V$ malejąco po $\deg(v)$; posortuj licencje malejąco po $\max$ i rosnąco po koszcie
\For{każdy $v\in V$ w tej kolejności}
  \If{$v\notin U$} \State \textit{kontynuuj} \EndIf
  \State $S \gets (N(v)\cup\{v\})\cap U$ \Comment kandydaci do grupy
  \State wybierz $\ell\in\mathcal{L}$ i podzbiór $G\subseteq S$ tak, aby zminimalizować $\mathrm{cost}(\ell)/|G|$ przy $|G|\in[\min_\ell,\min\{|S|,\max_\ell\}]$
  \If{wybór istnieje}
    \State dodaj grupę $(v,\ell,G)$ i ustaw $U\gets U\setminus G$
  \EndIf
\EndFor
\While{$U\neq\emptyset$}
  \State wybierz $u\in U$; jeśli możliwe – utwórz najmniejszą dopuszczalną grupę, w przeciwnym razie przydziel licencję indywidualną
  \State zaktualizuj $U$
\EndWhile
\State \Return zebrane grupy
\end{algorithmic}
\end{algorithm}

\subsection{Algorytm dla zbioru dominującego}

Najpierw wybieram kosztowo efektywny zbiór dominujący $D$, następnie każdemu dominatorowi przypisuję najtańszą dopuszczalną grupę; pozostałe węzły domykam analogicznie. Złożoność typowo $O(n^2T)$.

\begin{algorithm}[H]
\caption{Zbiór dominujący – heurystyka z przypisaniem grup}
\label{alg:ds}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, $\mathcal{L}$
\Ensure przydział grup oparty na MDS
\State $U\gets V$, $D\gets\emptyset$
\While{$U\neq\emptyset$}
  \State dla każdego $v$ policz $\mathrm{coverage}(v)=|(N(v)\cup\{v\})\cap U|$ i $\min\_\mathrm{cpn}(v)$
  \State wybierz $u$ maksymalizujące $\mathrm{coverage}(v)/\min\_\mathrm{cpn}(v)$; jeśli nie ma, weź dowolne $u\in U$
  \State $D\gets D\cup\{u\}$, $U\gets U\setminus(N(u)\cup\{u\})$
\EndWhile
\State posortuj $D$ malejąco po $\deg$
\For{każde $u\in D$ oraz dla pozostałych węzłów}
  \State $S\gets(N(u)\cup\{u\})\cap$ nieprzydzieleni
  \State wybierz najtańszą dopuszczalną grupę; w ostateczności licencję 1
\EndFor
\State \Return grupy
\end{algorithmic}
\end{algorithm}

\subsection{Algorytm losowy}

Jednoprzebiegowa procedura z elementem losowym i lokalnym „fallbackiem” zachłannym; parametr $p_{\mathrm{greedy}}$ steruje eksploracją/eksploatacją. Złożoność $\tilde O(|V|\Delta)$.

\begin{algorithm}[H]
\caption{Losowy – dobór licencji i składu grupy}
\label{alg:randomized}
\begin{algorithmic}[1]
\Require $G=(V,E)$, $\mathcal{L}$
\Ensure poprawny przydział
\State $U\gets V$, $\pi\gets$ losowa permutacja $V$
\For{node w kolejności $\pi$}
  \If{$node\notin U$} \textbf{continue}\EndIf
  \State $S\gets(N(node)\cup\{node\})\cap U$
  \If{$\exists$ dopuszczalna licencja}
    \State wylosuj $\ell$ i rozmiar $s\in[\min,\min\{|S|,\max\}]$, dobierz losowych członków
  \Else
    \State zrób mały krok zachłanny – wybierz najtańszą dopuszczalną grupę
  \EndIf
  \State dodaj grupę, zaktualizuj $U$
\EndFor
\While{$U\neq\emptyset$} przypisz najtańszą licencję 1 i usuń węzeł z $U$ \EndWhile
\end{algorithmic}
\end{algorithm}

\section{Metaheurystyki}

\subsection{Algorytm genetyczny}
Populacja rozwiązań z elityzmem, selekcją turniejową, krzyżowaniem i mutacją w przestrzeni sąsiedztw; start z heurystyki zachłannej i opcjonalnego warm-startu.

\begin{algorithm}[H]
\caption{Algorytm genetyczny – elityzm, krzyżowanie i mutacja}
\label{alg:ga}
\begin{algorithmic}[1]
\Require $G=(V,E)$, $\mathcal{L}$, parametry populacji
\Ensure przybliżony przydział
\State zainicjalizuj populację: opcjonalny warm start, rozwiązanie greedy, reszta losowo
\For{pokolenia}
  \State elita $\leftarrow$ top $\lceil f\cdot P\rceil$
  \While{$|New|<P$}
    \If{los $<cr$}
      \State $child\gets$ krzyżowanie rodziców i domknięcie greedy na niepokrytych
      \If{niepoprawny} $child\gets$ mutacja najlepszego z rodziców
    \Else
      \State $child\gets$ mutacja wygranego selekcji turniejowej
    \EndIf
  \EndWhile
  \State populacja $\gets$ elita $\cup$ potomstwo; aktualizuj $best$
\EndFor
\end{algorithmic}
\end{algorithm}

\subsection{Tabu Search}
Lokalne przeszukiwanie z tabu-listą i aspiracją; w każdej iteracji wybieram najlepszego sąsiada spoza tabu lub poprawiającego globalne optimum. Złożoność $O(I\cdot k\cdot C)$.

\begin{algorithm}[H]
\caption{Przeszukiwanie tabu – najlepszy sąsiad z pamięcią tabu}
\label{alg:tabu}
\begin{algorithmic}[1]
\Require $G=(V,E)$, $\mathcal{L}$, $\texttt{tabu\_tenure}$, $\texttt{max\_iterations}$
\Ensure przybliżony przydział
\State $current\gets$ greedy lub warm start; $best\gets current$
\State $tabu\_list\gets$ FIFO o długości \texttt{tabu\_tenure}
\For{do \texttt{max\_iterations}}
  \State $N\gets$ \texttt{generate\_neighbors}(current, k)
  \State wybierz najtańszego kandydata spoza tabu albo z aspiracją gdy poprawia $best$
  \State jeśli brak kandydata – przerwij; w przeciwnym razie zaktualizuj $current$, $best$ i $tabu\_list$
\EndFor
\State \Return $best$
\end{algorithmic}
\end{algorithm}

\subsection{Algorytm mrówkowy}
Mrówki konstruują rozwiązania sterowane feromonem $\tau$ i heurystyką $\eta$; po każdej iteracji parowanie $\rho$ i depozycja proporcjonalna do jakości najlepszego rozwiązania. Złożoność w przybliżeniu $O(\text{iter}\times\text{ants}\times(|V|+|E|))$.

\begin{algorithm}[H]
\caption{Algorytm mrówkowy – konstrukcja rozwiązań sterowana feromonami}
\label{alg:aco}
\begin{algorithmic}[1]
\Require $G=(V,E)$, $\mathcal{L}$, parametry $\alpha,\beta,\text{evap},q_0$
\Ensure przybliżony przydział
\State zainicjalizuj feromony i heurystyki; $best\gets$ greedy lub warm start; zdeponuj feromon
\For{iteracje}
  \For{każda mrówka}
    \State pokryj graf wybierając właściciela i licencję metodą best lub ruletką (parametr $q0$)
    \State waliduj i aktualizuj $best$ gdy koszt spada
  \EndFor
  \State paruj feromon i zdeponuj wzdłuż grup $best$
\EndFor
\State \Return $best$
\end{algorithmic}
\end{algorithm}

\subsection{Symulowane wyżarzanie (SA)}
Start z rozwiązania zachłannego, następnie ruchy sąsiedztwa z akceptacją pogorszeń zależną od temperatury $T$ i schładzaniem $T\leftarrow \alpha T$. Złożoność $O(I\cdot C)$ dla $I$ iteracji i kosztu oceny $C$.

\begin{algorithm}[H]
\caption{Wyżarzanie symulowane – sąsiedztwa i akceptacja pogorszeń}
\label{alg:sa}
\begin{algorithmic}[1]
\Require $G=(V,E)$, $\mathcal{L}$, parametry $T_0, T_{min}, \alpha$
\Ensure przybliżony przydział o niskim koszcie
\State $current\gets$ greedy lub warm start; $best\gets current$; $T\gets T_0$
\For{do \texttt{max\_iterations}}
  \If{$T<T_{min}$ lub deadline} \textbf{break} \EndIf
  \State wylosuj ruch z $\{$change\_license, move\_member, swap\_members, merge\_groups, split\_group$\}$
  \State jeśli kandydat poprawny: zaakceptuj z prawd. $\exp(-\Delta/\max(T,\varepsilon))$
  \State aktualizuj $best$, modyfikuj $T$ i licznik zastoju
\EndFor
\State \Return $best$
\end{algorithmic}
\end{algorithm}
