\chapter{Metody algorytmiczne}\label{chap:algorithms}

W tym rozdziale przedstawiono wszystkie algorytmy zastosowane w pracy. Każdy algorytm opisano wraz z jego główną ideą, parametrami oraz analizą złożoności obliczeniowej.

Algorytmy zastosowane w pracy można podzielić na cztery grupy:
\begin{enumerate}
  \item \textbf{Metody dokładne} -- gwarantują znalezienie optymalnego rozwiązania: algorytm naiwny i programowanie całkowitoliczbowe (ILP)
  \item \textbf{Metody dla drzew} -- programowanie dynamiczne na grafach drzewiastych
  \item \textbf{Heurystyki konstrukcyjne} -- szybkie metody budujące rozwiązanie krok po kroku: algorytm zachłanny, zbiór dominujący, algorytm losowy
  \item \textbf{Metaheurystyki} -- zaawansowane metody przeszukujące przestrzeń rozwiązań: algorytm genetyczny, przeszukiwanie tabu, algorytm mrówkowy, symulowane wyżarzanie
\end{enumerate}

\section{Formalizacja problemu}\label{sec:alg-conventions}

Problem składa się z grafu $G=(V,E)$ oraz zbioru typów licencji $\mathcal{L}=\{\ell_1,\dots,\ell_T\}$. Każda licencja $\ell$ ma trzy parametry: koszt $c_\ell>0$, minimalną pojemność $l_\ell$ i maksymalną pojemność $u_\ell$, gdzie $1\le l_\ell\le u_\ell$.

Grupa licencyjna składa się z właściciela $i$ (który kupuje licencję $\ell$) oraz członków grupy wybranych spośród sąsiadów właściciela. Oznaczając przez $N[i]$ zbiór składający się z wierzchołka $i$ i wszystkich jego sąsiadów, grupa licencyjna to podzbiór $G\subseteq N[i]$ taki, że właściciel $i$ należy do grupy ($i\in G$) oraz rozmiar grupy mieści się w dozwolonym zakresie ($l_\ell\le |G|\le u_\ell$).

Rozwiązaniem problemu jest taki zbiór grup $\mathcal{S}$, że każdy wierzchołek grafu należy do dokładnie jednej grupy. Koszt rozwiązania to suma kosztów wszystkich utworzonych grup: $\cost(\mathcal{S})=\sum\limits_{(i,\ell,G)\in\mathcal{S}} c_\ell$.

\section{Metody dokładne}

\subsection{Algorytm naiwny}

Algorytm naiwny to najprostsza metoda dokładna, która sprawdza wszystkie możliwe rozwiązania i wybiera najlepsze. Gwarantuje znalezienie optymalnego rozwiązania, ale działa tylko dla bardzo małych grafów.

\paragraph{Idea metody}
Algorytm systematycznie przegląda wszystkie możliwe podziały wierzchołków grafu na grupy licencyjne:
\begin{enumerate}
  \item Generuje wszystkie partycje zbioru wierzchołków
  \item Dla każdej partycji sprawdza wszystkie możliwe przypisania licencji
  \item Weryfikuje poprawność rozwiązania (ograniczenia spójności i pojemności)
  \item Oblicza koszt i zapamiętuje najlepsze rozwiązanie
\end{enumerate}

\begin{algorithm}[H]
\caption{Algorytm naiwny -- przegląd wszystkich możliwych rozwiązań}
\label{alg:naive}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
\If{$|V| > 10$} \State \Return błąd -- graf zbyt duży \EndIf
\State $best\_cost \gets \infty$, $best\_solution \gets \emptyset$
\For{każdą partycję $P = \{P_1, P_2, \dots, P_k\}$ zbioru $V$}
  \For{każde przypisanie licencji do bloków partycji}
    \If{rozwiązanie spełnia wszystkie ograniczenia}
      \State $cost \gets$ oblicz koszt rozwiązania
      \If{$cost < best\_cost$}
        \State $best\_cost \gets cost$, $best\_solution \gets$ obecne rozwiązanie
      \EndIf
    \EndIf
  \EndFor
\EndFor
\State \Return $best\_solution$
\end{algorithmic}
\end{algorithm}

\paragraph{Złożoność i ograniczenia}
Algorytm ma złożoność nadwykładniczą $O(c^n)$ ze względu na konieczność przeglądu wszystkich partycji zbioru wierzchołków. Z tego powodu praktyczny jest tylko dla grafów o maksymalnie 10 wierzchołkach. Używany głównie jako punkt odniesienia do walidacji innych algorytmów.


\subsection{Programowanie całkowitoliczbowe (ILP)}\label{subsec:ilp}

Programowanie całkowitoliczbowe (Integer Linear Programming, ILP) to metoda dokładna, która formułuje problem jako zadanie optymalizacji liniowej ze zmiennymi całkowitoliczbowymi. Gwarantuje znalezienie optymalnego rozwiązania.

\paragraph{Idea metody}
Algorytm minimalizuje łączny koszt wszystkich utworzonych grup licencyjnych używając dwóch typów zmiennych binarnych:
\begin{itemize}
  \item $a_{i,\ell}$ -- aktywacja grupy w wierzchołku $i$ dla typu licencji $\ell$
  \item $x_{i,j,\ell}$ -- przypisanie wierzchołka $j$ do grupy właściciela $i$ z licencją $\ell$
\end{itemize}

Model matematyczny (dla $N[i] = N(i) \cup \{i\}$):
\begin{align}
\min\quad & \sum_{i\in V}\sum_{\ell\in\mathcal{L}} c_\ell\, a_{i,\ell} && \text{(funkcja celu)}\\[4pt]
& \sum_{\substack{i\in V:\\ j\in N[i]}}\sum_{\ell\in\mathcal{L}} x_{i,j,\ell} = 1 && \forall j\in V \quad \text{(pokrycie)} \\[2pt]
& l_\ell\, a_{i,\ell} \le \sum_{j\in N[i]} x_{i,j,\ell} \le u_\ell\, a_{i,\ell} && \forall i\in V,\ \ell\in\mathcal{L} \quad \text{(pojemności)} \\[2pt]
& x_{i,i,\ell} = a_{i,\ell} && \forall i\in V,\ \ell\in\mathcal{L} \quad \text{(właściciel w grupie)}
\end{align}

\paragraph{Złożoność i zastosowanie}
Liczba zmiennych rośnie jako $O(|V| \cdot |\mathcal{L}| \cdot \Delta)$, gdzie $\Delta$ to maksymalny stopień wierzchołka. Dla dużych i gęstych grafów czas obliczeń może być znaczny. Metoda używana jako:
\begin{itemize}
  \item Punkt odniesienia dla oceny jakości innych algorytmów
  \item Rozwiązanie dla małych instancji (do około 100-200 wierzchołków)
  \item Generator górnych ograniczeń dla heurystyk
\end{itemize}
Dla większych instancji stosuje się ograniczenie czasu działania solvera.

\section{Metody dla drzew}

\subsection{Programowanie dynamiczne na drzewach}\label{subsec:treedp}
Poniżej definiujemy stan, przejścia i złożoność. Rozważamy drzewo $T=(V,E)$ z korzeniem $r$ i kierujemy krawędzie od rodzica do dzieci. Dla $u\in V$ przez $\mathrm{ch}(u)$ oznaczamy dzieci i $d(u)=|\mathrm{ch}(u)|$.

\paragraph{Stan DP}
Rozważamy dwa stany dla każdego $u$:
\begin{itemize}
  \item $F(u)$ - minimalny koszt pokrycia poddrzewa $T_u$, gdy $u$ jest włączony do grupy \emph{rodzica} (nie może być właścicielem).
  \item $G(u)$ - minimalny koszt pokrycia $T_u$, gdy $u$ \emph{nie} jest włączony do grupy rodzica (może zostać właścicielem i dołączyć część dzieci).
\end{itemize}

\paragraph{Przejścia} Jeśli $u$ zostaje właścicielem z licencją $\ell$, wybieramy podzbiór dzieci $S\subseteq \mathrm{ch}(u)$ do dołączenia do grupy $u$ (pozostałe dzieci rozwiązujemy niezależnie). Warunek pojemności: $l_\ell \le 1+|S| \le u_\ell$.
\[
\textstyle\mathrm{Own}(u,\ell) \;=\; c_\ell\; +\! \sum\limits_{v\in S} F(v)\; +\! \sum\limits_{v\in \mathrm{ch}(u)\setminus S} G(v),\qquad S\subseteq\mathrm{ch}(u).
\]
Wtedy:
\[
F(u)= \sum\limits_{v\in\mathrm{ch}(u)} G(v),\qquad
G(u)= \min\limits_{\ell\in\mathcal{L}}\ \min\limits_{\substack{S\subseteq\mathrm{ch}(u) \\ l_\ell\le 1+|S|\le u_\ell}} \Bigl[ c_\ell + \sum\limits_{v\in S} F(v) + \sum\limits_{v\notin S} G(v) \Bigr].
\]
Stan korzenia: wynik końcowy to $G(r)$.

\paragraph{Złożoność} Dla każdego $u$ i licencji enumerujemy podzbiory $S\subseteq\mathrm{ch}(u)$ - koszt $\sum_u T\cdot 2^{d(u)}$, więc $\mathcal{O}\bigl(|V|\cdot T\cdot 2^{d_{\max}}\bigr)$. Dla stałego $d_{\max}$ czas jest liniowy względem $|V|\cdot T$. Pamięć: $\mathcal{O}(|V|)$.

\begin{algorithm}[H]
\caption{Programowanie dynamiczne na drzewach}
\label{alg:treedp}
\begin{algorithmic}[1]
\Require drzewo $T=(V,E)$, typy licencji $\mathcal{L}$
\State wybierz korzeń $r$ i obliczaj dla każdego $u$ w porządku postorder:
\For{każdy wierzchołek $u$ (od liści do korzenia)}
  \State oblicz minimalny koszt pokrycia poddrzewa $u$ dla wszystkich możliwych konfiguracji
  \State rozważ $u$ jako właściciela różnych typów licencji z różnymi podzbiorami dzieci
  \State rozważ $u$ jako członka grupy rodzica
\EndFor
\State \Return optymalny koszt i rozwiązanie dla korzenia $r$
\end{algorithmic}
\end{algorithm}

\paragraph{Uwagi praktyczne}
Metoda zapewnia optimum na drzewach. W zastosowaniach praktycznych bywa użyteczna także na grafach bliskich drzewom po zastosowaniu heurystyk dekompozycji (np. usunięcie krawędzi o małym znaczeniu), lecz wtedy traci się gwarancję optymalności.

\section{Heurystyki konstrukcyjne}

\subsection{Algorytm zachłanny}\label{subsec:greedy}

Algorytm zachłanny to szybka heurystyka, która buduje rozwiązanie krok po kroku, w każdym kroku wybierając lokalnie najlepszą opcję. Algorytm nie gwarantuje znalezienia optymalnego rozwiązania, ale jest bardzo szybki i daje zazwyczaj dobre wyniki.

\paragraph{Idea metody}
Algorytm działa według następującej strategii:
\begin{enumerate}
  \item Sortuje wierzchołki malejąco według liczby sąsiadów (stopnia wierzchołka)
  \item Dla każdego wierzchołka sprawdza, czy może być właścicielem grupy
  \item Wybiera typ licencji i rozmiar grupy tak, aby zminimalizować stosunek kosztu do rozmiaru grupy
  \item Dodaje członków do grupy wybierając wierzchołki o największej liczbie sąsiadów
  \item Powtarza proces dla wszystkich niepokrytych wierzchołków
\end{enumerate}

Algorytm nie ma parametrów do dostrajania — wszystkie decyzje są podejmowane deterministycznie na podstawie struktury grafu i kosztów licencji.

\paragraph{Porządek wierzchołków}
Sortowanie według stopnia wierzchołka (liczby sąsiadów) sprawdza się dobrze w praktyce, ponieważ wierzchołki o wysokim stopniu mogą tworzyć większe, bardziej efektywne grupy licencyjne.

\paragraph{Złożoność}
Algorytm ma złożoność czasową $O(nT + m\log n)$, gdzie $n$ to liczba wierzchołków, $T$ to liczba typów licencji, a $m$ to liczba krawędzi. Zużywa $O(n)$ pamięci.

\begin{algorithm}[H]
\caption{Algorytm zachłanny}
\label{alg:greedy}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
\State posortuj wierzchołki malejąco według stopnia (najlepiej połączone pierwsze)
\State $niepokryte \gets V$
\For{każdy wierzchołek $v$ w posortowanej kolejności}
  \If{$v$ już pokryty} \textbf{continue} \EndIf
  \State znajdź dostępnych sąsiadów $v$ wśród niepokrytych
  \For{każdy typ licencji $\ell$}
    \State oblicz efektywność: $koszt_\ell / rozmiar\_grupy$
  \EndFor
  \State wybierz licencję i członków grupy o najlepszej efektywności
  \State utwórz grupę z $v$ jako właścicielem
  \State usuń członków grupy z $niepokryte$
\EndFor
\State \Return utworzone grupy
\end{algorithmic}
\end{algorithm}

\paragraph{Zastosowanie}
Algorytm zachłanny jest bardzo szybki i daje stabilne wyniki. Z tego powodu często używa się go jako:
\begin{itemize}
  \item Podstawową metodę do porównywania z innymi algorytmami
  \item Źródło rozwiązania początkowego dla bardziej zaawansowanych metod
  \item Szybką metodę dla dużych grafów, gdzie inne algorytmy są zbyt wolne
\end{itemize}
Wadą algorytmu jest to, że podejmując lokalnie najlepsze decyzje, może przegapić lepsze rozwiązania globalne.

\subsection{Heurystyka zbioru dominującego (\texttt{dominating\_set})}\label{subsec:ds}

Algorytm najpierw buduje zbiór dominujący grafuzyskując wierzchołki o najlepszej efektywności kosztowej (stosunek liczby pokrywanych sąsiadów do minimalnego kosztu na węzeł). Następnie każdemu dominatorowi przypisuje najtańszą dopuszczalną licencję i tworzy grupę.

\begin{algorithm}[H]
\caption{Zbiór dominujący -- heurystyka z przypisaniem grup}
\label{alg:ds}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, $\mathcal{L}$
\State $U\gets V$, $D\gets\emptyset$
\While{$U\neq\emptyset$}
  \State dla każdego $v$ policz $\mathrm{coverage}(v)=|(N(v)\cup\{v\})\cap U|$ i $\min\_\mathrm{cpn}(v)$
  \State wybierz $u$ maksymalizujące $\mathrm{coverage}(v)/\min\_\mathrm{cpn}(v)$; jeśli nie ma, weź dowolne $u\in U$
  \State $D\gets D\cup\{u\}$, $U\gets U\setminus(N(u)\cup\{u\})$
\EndWhile
\State posortuj $D$ malejąco po $\deg$
\For{każde $u\in D$ oraz dla pozostałych węzłów}
  \State $S\gets(N(u)\cup\{u\})\cap$ nieprzydzieleni
  \State wybierz najtańszą dopuszczalną grupę; w ostateczności licencję 1
\EndFor
\State \Return grupy
\end{algorithmic}
\end{algorithm}

\paragraph{Uwagi praktyczne}
Budowanie rozwiązania wokół \emph{maksymalnego} zbioru dominującego (niekoniecznie minimalnego) jest typową praktyką heurystyczną \cite{haynes1998domination}. Nasza wersja używa kryterium efektywności kosztowej i po doborze $D$ przypisuje grupy zgodnie z ograniczeniami pojemności. Metoda sprzyja niskim kosztom na grafach o wyraźnych „centrach” (BA) i niewielkich średnicach (WS), jest szybka, lecz podatna na wybór porządku; zwykle warto łączyć ją z rozgrzewką zachłanną lub lokalną poprawą.

\subsection{Algorytm losowy}\label{subsec:random}

Algorytm losowy służy jako punkt odniesienia (baseline) do oceny jakości innych metod. Jeśli którykolwiek algorytm osiąga gorsze wyniki niż losowy wybór, oznacza to fundamentalną wadę w jego implementacji lub doborze parametrów.

Algorytm przetwarza wierzchołki w losowej kolejności i dla każdego z nich losowo wybiera typ licencji oraz członków grupy. Gdy losowy wybór nie jest możliwy, używa strategii zachłannej jako fallback.

\begin{algorithm}[H]
\caption{Losowy -- dobór licencji i składu grupy}
\label{alg:randomized}
\begin{algorithmic}[1]
\Require $G=(V,E)$, $\mathcal{L}$
\State $U\gets V$, $\pi\gets$ losowa permutacja $V$
\For{node w kolejności $\pi$}
  \If{$node\notin U$} \textbf{continue}\EndIf
  \State $S\gets(N(node)\cup\{node\})\cap U$
  \If{$\exists$ dopuszczalna licencja}
    \State wylosuj $\ell$ i rozmiar $s\in[l_\ell,\min\{|S|,u_\ell\}]$, dobierz losowych członków
  \Else
    \State zrób mały krok zachłanny - wybierz najtańszą dopuszczalną grupę
  \EndIf
  \State dodaj grupę, zaktualizuj $U$
\EndFor
\While{$U\neq\emptyset$} przypisz najtańszą licencję 1 i usuń węzeł z $U$ \EndWhile
\end{algorithmic}
\end{algorithm}

\paragraph{Rola w badaniach}
Algorytm losowy nie ma na celu znajdowania dobrych rozwiązań. Jest używany wyłącznie jako baseline do weryfikacji, że inne algorytmy rzeczywiście dodają wartość ponad przypadkowy wybór. Każda metoda, która osiąga gorsze wyniki niż algorytm losowy, powinna zostać odrzucona lub przeprojektowana.

\section{Metaheurystyki}

Metaheurystyki to zaawansowane algorytmy przeszukujące przestrzeń rozwiązań w sposób inteligentny. W przeciwieństwie do heurystyk konstrukcyjnych, które budują rozwiązanie od zera, metaheurystyki zaczynają od pewnego rozwiązania i systematycznie je poprawiają.

\paragraph{Dobór parametrów}
Parametry metaheurystyk zostały dobrane eksperymentalnie na podstawie testów na grafach różnych rozmiarów. Używane są standardowe wartości z literatury, dostosowane do specyfiki problemu licencyjnego.

\paragraph{Reprezentacja rozwiązania}
Wszystkie metaheurystyki używają tego samego sposobu reprezentacji rozwiązania:
\begin{itemize}
  \item Wektor właścicieli $a$ -- dla każdego wierzchołka przechowuje informację o tym, czy jest właścicielem grupy i jakiej licencji używa
  \item Wektor przypisań $p$ -- dla każdego wierzchołka przechowuje informację o tym, do której grupy należy
\end{itemize}

\paragraph{Operacje modyfikacji rozwiązania}
Metaheurystyki poprawiają rozwiązanie stosując następujące operacje:
\begin{itemize}
  \item \texttt{change\_license} -- zmiana typu licencji używanej przez właściciela grupy
  \item \texttt{move\_member} -- przeniesienie członka z jednej grupy do drugiej
  \item \texttt{swap\_members} -- zamiana miejscami dwóch członków z różnych grup
  \item \texttt{merge\_groups}$(i,k)$ / \texttt{split\_group}$(i)$: scal dwie grupy w jedną (jeśli $\le u_\ell$) lub rozdziel na dwie dopuszczalne.
\end{itemize}

\subsection{Algorytm genetyczny (\texttt{genetic})}\label{subsec:ga}
Populacja rozwiązań z elityzmem, selekcją turniejową, krzyżowaniem (łączenie grup rodziców według efektywności i domknięcie greedy na niepokrytych) oraz mutacją w przestrzeni sąsiedztw; start z heurystyki zachłannej i opcjonalnego warm-startu \cite{holland1975,goldberg1989}.

\paragraph{Parametry}
Wielkość populacji (30), liczba pokoleń (40), udział elity (20\%) oraz prawdopodobieństwo krzyżowania (60\%).

\begin{algorithm}[H]
\caption{Algorytm genetyczny}
\label{alg:ga}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
\State utwórz populację początkową (zachłanny + losowe rozwiązania)
\For{każde pokolenie}
  \State oceń wszystkie rozwiązania (funkcja kosztu)
  \State zachowaj elitę (najlepsze rozwiązania)
  \While{populacja niepełna}
    \If{losowanie krzyżowania}
      \State wybierz dwóch rodziców (selekcja turniejowa)
      \State skrzyżuj rodziców (połącz efektywne grupy)
    \Else
      \State wybierz rozwiązanie i zmutuj (operacje sąsiedztwa)
    \EndIf
    \State dodaj potomka do nowej populacji
  \EndWhile
  \State zaktualizuj najlepsze znalezione rozwiązanie
\EndFor
\State \Return najlepsze rozwiązanie
\end{algorithmic}
\end{algorithm}

\paragraph{Uwagi praktyczne}
Algorytm genetyczny dobrze równoważy eksplorację nowych rozwiązań z eksploatacją znalezionych. Najlepsze wyniki uzyskuje przy umiarkowanym budżecie czasowym i dobrym rozwiązaniu początkowym.

\subsection{Przeszukiwanie tabu (\texttt{tabu\_search})}\label{subsec:tabu}
Lokalne przeszukiwanie z tabu-listą i kryterium aspiracji \cite{glover1989}; w każdej iteracji wybierany jest najlepszy sąsiad spoza tabu albo poprawiający dotychczas najlepsze rozwiązanie. \emph{Ruch} to jedna z operacji sąsiedztwa zdefiniowanych wyżej, a \emph{kluczem tabu} jest para opisująca odwrócony przydział $(j, i\to k)$ albo zmiana licencji $(i,\ell\to\ell')$. Złożoność $O(I\cdot k\cdot C)$ dla \(I\) iteracji, \(k\) sąsiadów i kosztu oceny \(C\).

\paragraph{Parametry}
Maksymalna liczba iteracji (1000), długość listy tabu (20) oraz liczba badanych sąsiadów na iterację (10).

\begin{algorithm}[H]
\caption{Przeszukiwanie tabu}
\label{alg:tabu}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
\State $aktualne \gets$ rozwiązanie początkowe (zachłanne)
\State $najlepsze \gets aktualne$
\State $lista\_tabu \gets$ pusta lista o stałej długości
\For{każdą iterację}
  \State wygeneruj sąsiadów $aktualne$ (zmiana licencji, przeniesienie członka, itp.)
  \State wybierz najlepszego sąsiada, który:
  \begin{itemize}[noitemsep]
    \item nie jest na liście tabu, LUB
    \item poprawia dotychczasowe $najlepsze$ (aspiracja)
  \end{itemize}
  \If{znaleziono kandydata}
    \State $aktualne \gets$ wybrany kandydat
    \State dodaj ruch do $lista\_tabu$
    \If{$aktualne$ lepsze niż $najlepsze$}
      \State $najlepsze \gets aktualne$
    \EndIf
  \EndIf
\EndFor
\State \Return $najlepsze$
\end{algorithmic}
\end{algorithm}

\paragraph{Uwagi praktyczne}
Przeszukiwanie tabu sprawdza się na dużych instancjach dzięki systematycznemu unikaniu cykli. Kluczowe jest odpowiednie dobranie długości listy tabu i zastosowanie kryterium aspiracji dla ruchów poprawiających najlepsze rozwiązanie.

\subsection{Algorytm mrówkowy (\texttt{ant\_colony\_optimization})}\label{subsec:aco}
Mrówki konstruują rozwiązania sterowane feromonem \(\tau\) i heurystyką \(\eta\) \cite{dorigo1997}; po każdej iteracji następuje parowanie (parametr \texttt{evaporation}) i depozycja proporcjonalna do odwrotności kosztu najlepszego rozwiązania. Złożoność w przybliżeniu \(O(\text{iter}\times\text{ants}\times(|V|+|E|+T))\).

\paragraph{Parametry}
Wpływ feromonu α=1, wpływ heurystyki β=2, tempo parowania (0.5), prawdopodobieństwo wyboru zachłannego q₀=0.9 oraz liczba mrówek (20).

\begin{algorithm}[H]
\caption{Algorytm mrówkowy}
\label{alg:aco}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
\State zainicjalizuj feromony $\tau$ (dla par wierzchołek-licencja)
\State zainicjalizuj heurystyki $\eta$ (na podstawie stopni wierzchołków i kosztów licencji)
\State $najlepsze \gets$ rozwiązanie początkowe (zachłanne)
\For{każdą iterację}
  \For{każdą mrówkę}
    \State $niepokryte \gets V$
    \While{$niepokryte \neq \emptyset$}
      \State wybierz właściciela na podstawie $\tau$ i $\eta$ (reguła wyboru lub ruletka)
      \State wybierz typ licencji na podstawie $\tau$ i $\eta$
      \State utwórz grupę, usuń członków z $niepokryte$
    \EndWhile
    \If{mrówka znalazła lepsze rozwiązanie}
      \State $najlepsze \gets$ rozwiązanie mrówki
    \EndIf
  \EndFor
  \State wyparuj część feromonów: $\tau \gets \tau \cdot (1-evaporation)$
  \State wzmocnij feromony na ścieżce $najlepsze$: $\tau \gets \tau + 1/koszt$
\EndFor
\State \Return $najlepsze$
\end{algorithmic}
\end{algorithm}

\paragraph{Uwagi praktyczne}
ACO dobrze radzi sobie na grafach, gdzie lokalne wskazówki (np. stopnie wierzchołków czy koszt jednostkowy licencji) korelują z jakością globalną. Wysokie \texttt{alpha} wzmacnia eksploatację już odkrytych ścieżek, natomiast wyższe \texttt{beta} i niższe \texttt{q0} zwiększają eksplorację. Zbyt wolne parowanie może prowadzić do zastoju, zbyt szybkie - do braku konsolidacji feromonu.

\subsection{Symulowane wyżarzanie (\texttt{simulated\_annealing})}\label{subsec:sa}
Start z rozwiązania zachłannego, następnie ruchy sąsiedztwa z akceptacją pogorszeń zależną od temperatury \(T\) i schładzaniem \(T\leftarrow \alpha T\) \cite{kirkpatrick1983}. Złożoność \(O(I\cdot C)\) dla \(I\) iteracji i kosztu oceny \(C\).

\paragraph{Parametry}
Temperatura początkowa (100.0), współczynnik chłodzenia (0.995), temperatura minimalna (0.001) oraz maksymalna liczba iteracji (20000).

\begin{algorithm}[H]
\caption{Symulowane wyżarzanie}
\label{alg:sa}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
\State $aktualne \gets$ rozwiązanie początkowe (zachłanne)
\State $najlepsze \gets aktualne$
\State $temperatura \gets T_0$ (początkowa temperatura)
\For{każdą iterację}
  \If{$temperatura < T_{min}$} \textbf{break} \EndIf
  \State wybierz losową operację sąsiedztwa:
  \begin{itemize}[noitemsep]
    \item zmień typ licencji w grupie
    \item przenieś członka między grupami
    \item zamień członków między grupami
    \item scal lub rozdziel grupy
  \end{itemize}
  \State $kandydat \gets$ wynik operacji sąsiedztwa
  \State $\Delta \gets koszt(kandydat) - koszt(aktualne)$
  \If{$\Delta \leq 0$ LUB $random() < \exp(-\Delta / temperatura)$}
    \State $aktualne \gets kandydat$
    \If{$koszt(kandydat) < koszt(najlepsze)$}
      \State $najlepsze \gets kandydat$
    \EndIf
  \EndIf
  \State $temperatura \gets temperatura \cdot cooling\_rate$
\EndFor
\State \Return $najlepsze$
\end{algorithmic}
\end{algorithm}

\paragraph{Uwagi praktyczne}
Wyżarzanie symulowane jest proste w implementacji i elastyczne. Wysoka temperatura początkowa oraz wolne chłodzenie zwiększają zdolność do ucieczki z minimów lokalnych kosztem dłuższego czasu działania. W praktyce skuteczne bywa łączenie z rozwiązaniem początkowym z heurystyki zachłannej oraz ograniczanie zbioru ruchów do tych, które najszybciej obniżają koszt.
