\chapter{Metody algorytmiczne}\label{chap:algorithms}

W tym rozdziale przedstawiono wszystkie algorytmy zastosowane w pracy. Każdy algorytm opisano wraz z jego główną ideą, parametrami oraz analizą złożoności obliczeniowej.


Algorytmy zastosowane w pracy można podzielić na trzy grupy:
\begin{enumerate}
  \item \textbf{Metody dokładne} -- gwarantują znalezienie optymalnego rozwiązania: algorytm naiwny i programowanie całkowitoliczbowe (ILP).
  \item \textbf{Heurystyki konstrukcyjne} -- szybkie metody budujące rozwiązanie krok po kroku: algorytm zachłanny, zbiór dominujący, algorytm losowy.
  \item \textbf{Metaheurystyki} -- zaawansowane metody przeszukujące przestrzeń rozwiązań: algorytm genetyczny, przeszukiwanie tabu, algorytm mrówkowy, symulowane wyżarzanie.
\end{enumerate}

% \section{Formalizacja problemu}\label{sec:alg-conventions}

% Problem składa się z grafu $G=(V,E)$ oraz zbioru typów licencji $\mathcal{L}=\{\ell_1,\dots,\ell_T\}$. Każda licencja $\ell$ ma trzy parametry: koszt $c_\ell>0$, minimalną pojemność $l_\ell$ i maksymalną pojemność $u_\ell$, gdzie $1\le l_\ell\le u_\ell$.

% Grupa licencyjna składa się z właściciela $i$ (który kupuje licencję $\ell$) oraz członków grupy wybranych spośród sąsiadów właściciela. Oznaczając przez $N[i]$ zbiór składający się z wierzchołka $i$ i wszystkich jego sąsiadów, grupa licencyjna to podzbiór $G\subseteq N[i]$ taki, że właściciel $i$ należy do grupy ($i\in G$) oraz rozmiar grupy mieści się w dozwolonym zakresie ($l_\ell\le |G|\le u_\ell$).

% Rozwiązaniem problemu jest taki zbiór grup $\mathcal{S}$, że każdy wierzchołek grafu należy do dokładnie jednej grupy. Koszt rozwiązania to suma kosztów wszystkich utworzonych grup: $\cost(\mathcal{S})=\sum\limits_{(i,\ell,G)\in\mathcal{S}} c_\ell$.

\section{Metody dokładne}

\subsection{Algorytm naiwny}

Algorytm naiwny to najprostsza metoda dokładna, która sprawdza wszystkie możliwe rozwiązania i wybiera najlepsze. Gwarantuje znalezienie optymalnego rozwiązania, ale działa tylko dla bardzo małych grafów.

\paragraph{Idea metody}
Algorytm systematycznie przegląda wszystkie możliwe podziały wierzchołków grafu na grupy licencyjne:
\begin{enumerate}
  \item Generuje wszystkie partycje zbioru wierzchołków.
  \item Dla każdej partycji sprawdza wszystkie możliwe przypisania licencji.
  \item Weryfikuje poprawność rozwiązania.
  \item Oblicza koszt i zapamiętuje najlepsze rozwiązanie.
\end{enumerate}

\begin{algorithm}[H]
\caption{Algorytm naiwny -- przegląd wszystkich możliwych rozwiązań}
\label{alg:naive}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
\If{$|V| > 10$} \State \Return błąd -- graf zbyt duży \EndIf
\State $best\_cost \gets \infty$, $best\_solution \gets \emptyset$
\For{każda partycja $P = \{P_1, P_2, \dots, P_k\}$ zbioru $V$}
  \For{każde przypisanie licencji do bloków partycji}
    \If{rozwiązanie spełnia wszystkie ograniczenia}
      \State $cost \gets$ oblicz koszt rozwiązania
      \If{$cost < best\_cost$}
        \State $best\_cost \gets cost$, $best\_solution \gets$ obecne rozwiązanie
      \EndIf
    \EndIf
  \EndFor
\EndFor
\State \Return $best\_solution$
\end{algorithmic}
\end{algorithm}

\paragraph{Złożoność}
Algorytm ma złożoność nadwykładniczą $O(c^n)$ ze względu na konieczność przeglądu wszystkich partycji zbioru wierzchołków. Z tego powodu praktyczny jest tylko dla grafów o maksymalnie 10 wierzchołkach. Używany głównie jako punkt odniesienia do walidacji innych algorytmów.


\subsection{Programowanie całkowitoliczbowe (ILP)}\label{subsec:ilp}

Programowanie całkowitoliczbowe to metoda dokładna, która formułuje problem jako zadanie optymalizacji liniowej ze zmiennymi całkowitoliczbowymi. Gwarantuje znalezienie optymalnego rozwiązania.

\paragraph{Idea metody}
Algorytm minimalizuje łączny koszt wszystkich utworzonych grup licencyjnych używając dwóch typów zmiennych binarnych:
\begin{itemize}
  \item $a_{i,\ell}$ -- aktywacja grupy w wierzchołku $i$ dla typu licencji $\ell$
  \item $x_{i,j,\ell}$ -- przypisanie wierzchołka $j$ do grupy właściciela $i$ z licencją $\ell$
\end{itemize}

Model matematyczny (dla $N[i] = N(i) \cup \{i\}$):
\begin{align}
\min\quad & \sum_{i\in V}\sum_{\ell\in\mathcal{L}} c_\ell\, a_{i,\ell} && \text{(funkcja celu)}\\[4pt]
& \sum_{\substack{i\in V:\\ j\in N[i]}}\sum_{\ell\in\mathcal{L}} x_{i,j,\ell} = 1 && \forall j\in V \quad \text{(pokrycie)} \\[2pt]
& l_\ell\, a_{i,\ell} \le \sum_{j\in N[i]} x_{i,j,\ell} \le u_\ell\, a_{i,\ell} && \forall i\in V,\ \ell\in\mathcal{L} \quad \text{(pojemności)} \\[2pt]
& x_{i,i,\ell} = a_{i,\ell} && \forall i\in V,\ \ell\in\mathcal{L} \quad \text{(właściciel w grupie)}
\end{align}

\paragraph{Złożoność}
Liczba zmiennych rośnie jako $O(|V| \cdot |\mathcal{L}| \cdot \Delta)$, gdzie $\Delta$ to maksymalny stopień wierzchołka. Dla dużych i gęstych grafów czas obliczeń może być znaczny. Metoda używana jako:
\begin{itemize}
  \item punkt odniesienia dla oceny jakości innych algorytmów,
  \item rozwiązanie dla małych instancji (do około 100-200 wierzchołków),
  \item generator górnych ograniczeń dla heurystyk.
\end{itemize}

\section{Heurystyki konstrukcyjne}

\subsection{Algorytm zachłanny}\label{subsec:greedy}

Algorytm zachłanny to szybka heurystyka, która buduje rozwiązanie krok po kroku, w każdym kroku wybierając lokalnie najlepszą opcję. Algorytm nie gwarantuje znalezienia optymalnego rozwiązania, ale jest bardzo szybki i daje zazwyczaj dobre wyniki.

\paragraph{Idea metody}
Algorytm działa według następującej strategii:
\begin{enumerate}
  \item Sortuje wierzchołki malejąco według liczby sąsiadów (stopnia wierzchołka)
  \item Dla każdego wierzchołka sprawdza, czy może być właścicielem grupy
  \item Wybiera typ licencji i rozmiar grupy tak, aby zminimalizować stosunek kosztu do rozmiaru grupy
  \item Dodaje członków do grupy wybierając wierzchołki o największej liczbie sąsiadów
  \item Powtarza proces dla wszystkich niepokrytych wierzchołków
\end{enumerate}

Algorytm nie ma parametrów do dostrajania — wszystkie decyzje są podejmowane deterministycznie na podstawie struktury grafu i kosztów licencji.

Sortowanie według stopnia wierzchołka (liczby sąsiadów) sprawdza się dobrze w praktyce, ponieważ wierzchołki o wysokim stopniu mogą tworzyć większe, bardziej efektywne grupy licencyjne.

\paragraph{Złożoność}
Algorytm ma złożoność czasową $O(nT + m\log n)$, gdzie $n$ to liczba wierzchołków, $T$ to liczba typów licencji, a $m$ to liczba krawędzi.

\begin{algorithm}[H]
\caption{Algorytm zachłanny}
\label{alg:greedy}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
\State posortuj wierzchołki malejąco według stopnia
\State $niepokryte \gets V$
\For{każdy wierzchołek $v$ w posortowanej kolejności}
  \If{$v$ już pokryty} \textbf{continue} \EndIf
  \State znajdź dostępnych sąsiadów $v$ wśród niepokrytych
  \For{każdy typ licencji $\ell$}
    \State oblicz efektywność: $koszt_\ell / rozmiar\_grupy$
  \EndFor
  \State wybierz licencję i członków grupy o najlepszej efektywności
  \State utwórz grupę z $v$ jako właścicielem
  \State usuń członków grupy z $niepokryte$
\EndFor
\State \Return utworzone grupy
\end{algorithmic}
\end{algorithm}

\paragraph{Zastosowanie}
Algorytm zachłanny jest bardzo szybki i daje stabilne wyniki. Z tego powodu często używa się go jako:
\begin{itemize}
  \item Podstawową metodę do porównywania z innymi algorytmami
  \item Źródło rozwiązania początkowego dla bardziej zaawansowanych metod
  \item Szybką metodę dla dużych grafów, gdzie inne algorytmy są zbyt wolne
\end{itemize}
Wadą algorytmu jest to, że podejmując lokalnie najlepsze decyzje, może przegapić lepsze rozwiązania globalne.

\subsection{Heurystyka zbioru dominującego}\label{subsec:ds}

Algorytm najpierw buduje zbiór dominujący grafu zyskując wierzchołki o najlepszej efektywności kosztowej (stosunek liczby pokrywanych sąsiadów do minimalnego kosztu na węzeł). Następnie każdemu dominatorowi przypisuje najtańszą dopuszczalną licencję i tworzy grupę.

\begin{algorithm}[H]
\caption{Zbiór dominujący -- heurystyka z przypisaniem grup}
\label{alg:ds}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, $\mathcal{L}$
\State $U\gets V$, $D\gets\emptyset$
\While{$U\neq\emptyset$}
  \State dla każdego $v$ policz $\mathrm{coverage}(v)=|(N(v)\cup\{v\})\cap U|$ i $\min\_\mathrm{cpn}(v)$
  \State wybierz $u$ maksymalizujące $\mathrm{coverage}(v)/\min\_\mathrm{cpn}(v)$; jeśli nie ma, weź dowolne $u\in U$
  \State $D\gets D\cup\{u\}$, $U\gets U\setminus(N(u)\cup\{u\})$
\EndWhile
\State posortuj $D$ malejąco po $\deg$
\For{każde $u\in D$ oraz dla pozostałych węzłów}
  \State $S\gets(N(u)\cup\{u\})\cap$ nieprzydzieleni
  \State wybierz najtańszą dopuszczalną grupę; w ostateczności licencję 1
\EndFor
\State \Return grupy
\end{algorithmic}
\end{algorithm}

Budowanie rozwiązania wokół \emph{maksymalnego} zbioru dominującego (niekoniecznie minimalnego) jest typową praktyką heurystyczną \cite{haynes1998domination}. Nasza wersja używa kryterium efektywności kosztowej i po doborze $D$ przypisuje grupy zgodnie z ograniczeniami pojemności.

\subsection{Algorytm losowy}\label{subsec:random}

Algorytm losowy służy jako punkt odniesienia do oceny jakości innych metod. Jeśli którykolwiek algorytm osiąga gorsze wyniki niż losowy wybór, oznacza to fundamentalną wadę w jego implementacji lub doborze parametrów.

Algorytm przetwarza wierzchołki w losowej kolejności i dla każdego z nich losowo wybiera typ licencji oraz członków grupy. Gdy losowy wybór nie jest możliwy, używa strategii zachłannej jako fallback.

\begin{algorithm}[H]
\caption{Losowy -- dobór licencji i składu grupy}
\label{alg:randomized}
\begin{algorithmic}[1]
\Require $G=(V,E)$, $\mathcal{L}$
\State $U\gets V$, $\pi\gets$ losowa permutacja $V$
\For{node w kolejności $\pi$}
  \If{$node\notin U$} \textbf{continue}\EndIf
  \State $S\gets(N(node)\cup\{node\})\cap U$
  \If{istnieje dopuszczalna licencja}
    \State wylosuj $\ell$ i rozmiar $s\in[l_\ell,\min\{|S|,u_\ell\}]$, dobierz losowych członków
  \Else
    \State wybierz najtańszą dopuszczalną grupę
  \EndIf
  \State dodaj grupę, zaktualizuj $U$
\EndFor
\While{$U\neq\emptyset$} przypisz najtańszą licencję 1 i usuń węzeł z $U$ \EndWhile
\end{algorithmic}
\end{algorithm}


\section{Metaheurystyki}

Metaheurystyki to zaawansowane algorytmy przeszukujące przestrzeń rozwiązań w sposób inteligentny. W przeciwieństwie do heurystyk konstrukcyjnych, które budują rozwiązanie od zera, metaheurystyki zaczynają od pewnego rozwiązania i systematycznie je poprawiają.

\paragraph{Dobór parametrów}
Parametry metaheurystyk zostały dobrane eksperymentalnie na podstawie testów na grafach różnych rozmiarów.

\paragraph{Operacje modyfikacji rozwiązania}
Metaheurystyki poprawiają rozwiązanie stosując następujące operacje:
\begin{itemize}
  \item zmiana typu licencji używanej przez właściciela grupy
  \item przeniesienie członka z jednej grupy do drugiej
  \item zamiana miejscami dwóch członków z różnych grup
  \item scal dwie grupy w jedną lub rozdziel na dwie dopuszczalne.
\end{itemize}

\subsection{Algorytm genetyczny}\label{subsec:ga}
Populacja rozwiązań z elityzmem, selekcją turniejową, krzyżowaniem oraz mutacją w przestrzeni sąsiedztw; start z heurystyki zachłannej \cite{holland1975,goldberg1989}.

\paragraph{Parametry}
Wielkość populacji (30), liczba pokoleń (40), udział elity (20\%) oraz prawdopodobieństwo krzyżowania (60\%).

\begin{algorithm}[H]
\caption{Algorytm genetyczny}
\label{alg:ga}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
\State utwórz populację początkową (zachłanny + losowe rozwiązania)
\For{każde pokolenie}
  \State oceń wszystkie rozwiązania (funkcja kosztu)
  \State zachowaj elitę (najlepsze rozwiązania)
  \While{populacja niepełna}
    \If{losowanie krzyżowania}
      \State wybierz dwóch rodziców (selekcja turniejowa)
      \State skrzyżuj rodziców (połącz efektywne grupy)
    \Else
      \State wybierz rozwiązanie i zmutuj (operacje sąsiedztwa)
    \EndIf
    \State dodaj potomka do nowej populacji
  \EndWhile
  \State zaktualizuj najlepsze znalezione rozwiązanie
\EndFor
\State \Return najlepsze rozwiązanie
\end{algorithmic}
\end{algorithm}



\subsection{Przeszukiwanie tabu}\label{subsec:tabu}
Lokalne przeszukiwanie z tabu-listą i kryterium aspiracji \cite{glover1989}; w każdej iteracji wybierany jest najlepszy sąsiad spoza tabu albo poprawiający dotychczas najlepsze rozwiązanie. \emph{Ruch} to jedna z operacji sąsiedztwa zdefiniowanych wyżej, a \emph{kluczem tabu} jest para opisująca odwrócony przydział $(j, i\to k)$ albo zmiana licencji $(i,\ell\to\ell')$. Złożoność $O(I\cdot k\cdot C)$ dla \(I\) iteracji, \(k\) sąsiadów i kosztu oceny \(C\).

\paragraph{Parametry}
Maksymalna liczba iteracji (1000), długość listy tabu (20) oraz liczba badanych sąsiadów na iterację (10).

\begin{algorithm}[H]
\caption{Przeszukiwanie tabu}
\label{alg:tabu}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
\State $aktualne \gets$ rozwiązanie początkowe (zachłanne)
\State $najlepsze \gets aktualne$
\State $lista\_tabu \gets$ pusta lista o stałej długości
\For{każdą iterację}
  \State wygeneruj sąsiadów $aktualne$ (zmiana licencji, przeniesienie członka, itp.)
  \State wybierz najlepszego sąsiada, który:
  \begin{itemize}[noitemsep]
    \item nie jest na liście tabu, LUB
    \item poprawia dotychczasowe $najlepsze$ (aspiracja)
  \end{itemize}
  \If{znaleziono kandydata}
    \State $aktualne \gets$ wybrany kandydat
    \State dodaj ruch do $lista\_tabu$
    \If{$aktualne$ lepsze niż $najlepsze$}
      \State $najlepsze \gets aktualne$
    \EndIf
  \EndIf
\EndFor
\State \Return $najlepsze$
\end{algorithmic}
\end{algorithm}


\subsection{Algorytm mrówkowy}\label{subsec:aco}
Mrówki konstruują rozwiązania sterowane feromonem \(\tau\) i heurystyką \(\eta\) \cite{dorigo1997}; po każdej iteracji następuje parowanie i depozycja proporcjonalna do odwrotności kosztu najlepszego rozwiązania. Złożoność w przybliżeniu \(O(\text{iter}\times\text{ants}\times(|V|+|E|+T))\).

\paragraph{Parametry}
Wpływ feromonu α=1, wpływ heurystyki β=2, tempo parowania (0.5), prawdopodobieństwo wyboru zachłannego q$_0$=0.9 oraz liczba mrówek (20).

\begin{algorithm}[H]
\caption{Algorytm mrówkowy}
\label{alg:aco}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
\State zainicjalizuj feromony $\tau$ (dla par wierzchołek-licencja)
\State zainicjalizuj heurystyki $\eta$ (na podstawie stopni wierzchołków i kosztów licencji)
\State $najlepsze \gets$ rozwiązanie początkowe (zachłanne)
\For{każdą iterację}
  \For{każdą mrówkę}
    \State $niepokryte \gets V$
    \While{$niepokryte \neq \emptyset$}
      \State wybierz właściciela na podstawie $\tau$ i $\eta$ (reguła wyboru lub ruletka)
      \State wybierz typ licencji na podstawie $\tau$ i $\eta$
      \State utwórz grupę, usuń członków z $niepokryte$
    \EndWhile
    \If{mrówka znalazła lepsze rozwiązanie}
      \State $najlepsze \gets$ rozwiązanie mrówki
    \EndIf
  \EndFor
  \State wyparuj część feromonów: $\tau \gets \tau \cdot (1-evaporation)$
  \State wzmocnij feromony na ścieżce $najlepsze$: $\tau \gets \tau + 1/koszt$
\EndFor
\State \Return $najlepsze$
\end{algorithmic}
\end{algorithm}

\subsection{Symulowane wyżarzanie }\label{subsec:sa}
Start z rozwiązania zachłannego, następnie ruchy sąsiedztwa z akceptacją pogorszeń zależną od temperatury \(T\) i schładzaniem \(T\leftarrow \alpha T\) \cite{kirkpatrick1983}. Złożoność \(O(I\cdot C)\) dla \(I\) iteracji i kosztu oceny \(C\).

\paragraph{Parametry}
Temperatura początkowa (100.0), współczynnik chłodzenia (0.995), temperatura minimalna (0.001) oraz maksymalna liczba iteracji (20000).

\begin{algorithm}[H]
\caption{Symulowane wyżarzanie}
\label{alg:sa}
\begin{algorithmic}[1]
\Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
\State $aktualne \gets$ rozwiązanie początkowe (zachłanne)
\State $najlepsze \gets aktualne$
\State $temperatura \gets T_0$ (początkowa temperatura)
\For{każdą iterację}
  \If{$temperatura < T_{min}$} \textbf{break} \EndIf
  \State wybierz losową operację sąsiedztwa
  \State $kandydat \gets$ wynik operacji sąsiedztwa
  \State $\Delta \gets koszt(kandydat) - koszt(aktualne)$
  \If{$\Delta \leq 0$ LUB $random() < \exp(-\Delta / temperatura)$}
    \State $aktualne \gets kandydat$
    \If{$koszt(kandydat) < koszt(najlepsze)$}
      \State $najlepsze \gets kandydat$
    \EndIf
  \EndIf
  \State $temperatura \gets temperatura \cdot cooling\_rate$
\EndFor
\State \Return $najlepsze$
\end{algorithmic}
\end{algorithm}

