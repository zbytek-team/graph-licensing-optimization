\chapter{Metody algorytmiczne}\label{chap:algorithms}

W tym rozdziale przedstawiono wszystkie algorytmy zastosowane w pracy. Każdy algorytm opisano wraz z jego główną ideą, parametrami oraz analizą złożoności obliczeniowej.


Algorytmy zastosowane w pracy można podzielić na trzy grupy:
\begin{enumerate}
  \item \textbf{Metody dokładne} -- gwarantują znalezienie optymalnego rozwiązania: algorytm naiwny i programowanie całkowitoliczbowe (ILP).
  \item \textbf{Heurystyki konstrukcyjne} -- szybkie metody budujące rozwiązanie krok po kroku: algorytm zachłanny, zbiór dominujący, algorytm losowy.
  \item \textbf{Metaheurystyki} -- zaawansowane metody przeszukujące przestrzeń rozwiązań: algorytm genetyczny, przeszukiwanie tabu, algorytm mrówkowy, symulowane wyżarzanie.
\end{enumerate}

% \section{Formalizacja problemu}\label{sec:alg-conventions}

% Problem składa się z grafu $G=(V,E)$ oraz zbioru typów licencji $\mathcal{L}=\{\ell_1,\dots,\ell_T\}$. Każda licencja $\ell$ ma trzy parametry: koszt $c_\ell>0$, minimalną pojemność $l_\ell$ i maksymalną pojemność $u_\ell$, gdzie $1\le l_\ell\le u_\ell$.

% Grupa licencyjna składa się z właściciela $i$ (który kupuje licencję $\ell$) oraz członków grupy wybranych spośród sąsiadów właściciela. Oznaczając przez $N[i]$ zbiór składający się z wierzchołka $i$ i wszystkich jego sąsiadów, grupa licencyjna to podzbiór $G\subseteq N[i]$ taki, że właściciel $i$ należy do grupy ($i\in G$) oraz rozmiar grupy mieści się w dozwolonym zakresie ($l_\ell\le |G|\le u_\ell$).

% Rozwiązaniem problemu jest taki zbiór grup $\mathcal{S}$, że każdy wierzchołek grafu należy do dokładnie jednej grupy. Koszt rozwiązania to suma kosztów wszystkich utworzonych grup: $\cost(\mathcal{S})=\sum\limits_{(i,\ell,G)\in\mathcal{S}} c_\ell$.

\section{Metody dokładne}

\subsection{Algorytm naiwny}

Algorytm naiwny to najprostsza metoda dokładna, która sprawdza wszystkie możliwe rozwiązania i wybiera najlepsze. Gwarantuje znalezienie optymalnego rozwiązania, ale działa tylko dla bardzo małych grafów.

\paragraph{Idea metody}
Algorytm systematycznie przegląda wszystkie możliwe podziały wierzchołków grafu na grupy licencyjne:
\begin{enumerate}
  \item Generuje wszystkie partycje zbioru wierzchołków.
  \item Dla każdej partycji sprawdza wszystkie możliwe przypisania licencji.
  \item Weryfikuje poprawność rozwiązania.
  \item Oblicza koszt i zapamiętuje najlepsze rozwiązanie.
\end{enumerate}

\begin{algorithm}[H]
  \caption{Algorytm naiwny -- przegląd wszystkich możliwych rozwiązań}
  \label{alg:naive}
  \begin{algorithmic}[1]
    \Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
    \If{$|V| > 10$} \State \Return błąd -- graf zbyt duży \EndIf
    \State $best\_cost \gets \infty$, $best\_solution \gets \emptyset$
    \For{każda partycja $P = \{P_1, P_2, \dots, P_k\}$ zbioru $V$}
    \For{każde przypisanie licencji do bloków partycji}
    \If{rozwiązanie spełnia wszystkie ograniczenia}
    \State $cost \gets$ oblicz koszt rozwiązania
    \If{$cost < best\_cost$}
    \State $best\_cost \gets cost$, $best\_solution \gets$ obecne rozwiązanie
    \EndIf
    \EndIf
    \EndFor
    \EndFor
    \State \Return $best\_solution$
  \end{algorithmic}
\end{algorithm}

\paragraph{Złożoność i zastosowanie}
Algorytm ma złożoność nadwykładniczą $O(c^n)$ ze względu na konieczność przeglądu wszystkich partycji zbioru wierzchołków. Z tego powodu praktyczny jest tylko dla grafów o maksymalnie 10 wierzchołkach. Używany był głównie jako punkt odniesienia do walidacji innych algorytmów.


\subsection{Programowanie całkowitoliczbowe (ILP)}\label{subsec:ilp}

Programowanie całkowitoliczbowe to metoda dokładna, która formułuje problem jako zadanie optymalizacji liniowej ze zmiennymi całkowitoliczbowymi. Gwarantuje znalezienie optymalnego rozwiązania.

\paragraph{Idea metody}
Algorytm minimalizuje łączny koszt wszystkich utworzonych grup licencyjnych używając dwóch typów zmiennych binarnych:
\begin{itemize}
  \item $a_{i,\ell}$ -- aktywacja grupy w wierzchołku $i$ dla typu licencji $\ell$
  \item $x_{i,j,\ell}$ -- przypisanie wierzchołka $j$ do grupy właściciela $i$ z licencją $\ell$
\end{itemize}

Model matematyczny (dla $N[i] = N(i) \cup \{i\}$):
\begin{align}
  \min\quad & \sum_{i\in V}\sum_{\ell\in\mathcal{L}} c_\ell\, a_{i,\ell}                    &  & \text{(funkcja celu)}                                                  \\[4pt]
            & \sum_{\substack{i\in V:                                                                                                                                   \\ j\in N[i]}}\sum_{\ell\in\mathcal{L}} x_{i,j,\ell} = 1 && \forall j\in V \quad \text{(pokrycie)} \\[2pt]
            & l_\ell\, a_{i,\ell} \le \sum_{j\in N[i]} x_{i,j,\ell} \le u_\ell\, a_{i,\ell} &  & \forall i\in V,\ \ell\in\mathcal{L} \quad \text{(pojemności)}          \\[2pt]
            & x_{i,i,\ell} = a_{i,\ell}                                                     &  & \forall i\in V,\ \ell\in\mathcal{L} \quad \text{(właściciel w grupie)}
\end{align}

\paragraph{Złożoność i zastosowanie}
Liczba zmiennych rośnie jako $O(|V| \cdot |\mathcal{L}| \cdot \Delta)$, gdzie $\Delta$ to maksymalny stopień wierzchołka. Dla dużych i gęstych grafów czas obliczeń może być znaczny. Metoda używana jako:
\begin{itemize}
  \item punkt odniesienia dla oceny jakości innych algorytmów,
  \item rozwiązanie dla małych instancji (do około 100-200 wierzchołków),
  \item generator górnych ograniczeń dla heurystyk.
\end{itemize}

\section{Heurystyki konstrukcyjne}

\subsection{Algorytm zachłanny}\label{subsec:greedy}

Algorytm zachłanny to szybka heurystyka, która buduje rozwiązanie krok po kroku, w każdym kroku wybierając lokalnie najlepszą opcję. Algorytm nie gwarantuje znalezienia optymalnego rozwiązania, ale jest bardzo szybki i daje zazwyczaj dobre wyniki.

\paragraph{Idea metody}
Algorytm działa według następującej strategii:
\begin{enumerate}
  \item Sortuje wierzchołki malejąco według liczby sąsiadów (stopnia wierzchołka)
  \item Dla każdego wierzchołka sprawdza, czy może być właścicielem grupy
  \item Wybiera typ licencji i rozmiar grupy tak, aby zminimalizować stosunek kosztu do rozmiaru grupy
  \item Dodaje członków do grupy wybierając wierzchołki o największej liczbie sąsiadów
  \item Powtarza proces dla wszystkich niepokrytych wierzchołków
\end{enumerate}

Algorytm nie ma parametrów do dostrajania -- wszystkie decyzje są podejmowane deterministycznie na podstawie struktury grafu i kosztów licencji.

Sortowanie według stopnia wierzchołka (liczby sąsiadów) sprawdza się dobrze w praktyce, ponieważ wierzchołki o wysokim stopniu mogą tworzyć większe, bardziej efektywne grupy licencyjne.

\begin{algorithm}[H]
  \caption{Algorytm zachłanny}
  \label{alg:greedy}
  \begin{algorithmic}[1]
    \Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
    \State posortuj wierzchołki malejąco według stopnia
    \State $niepokryte \gets V$
    \For{każdy wierzchołek $v$ w posortowanej kolejności}
    \If{$v$ już pokryty} \textbf{continue} \EndIf
    \State znajdź dostępnych sąsiadów $v$ wśród niepokrytych
    \For{każdy typ licencji $\ell$}
    \State oblicz efektywność: $koszt_\ell / rozmiar\_grupy$
    \EndFor
    \State wybierz licencję i członków grupy o najlepszej efektywności
    \State utwórz grupę z $v$ jako właścicielem
    \State usuń członków grupy z $niepokryte$
    \EndFor
    \State \Return utworzone grupy
  \end{algorithmic}
\end{algorithm}


\paragraph{Złożoność i zastosowanie}
Algorytm ma złożoność czasową $O(nT + m\log n)$, gdzie $n$ to liczba wierzchołków, $T$ to liczba typów licencji, a $m$ to liczba krawędzi.
Algorytm zachłanny jest bardzo szybki i daje stabilne wyniki. Z tego powodu często używany był jako:
\begin{itemize}
  \item podstawowa metoda do porównywania z innymi algorytmami,
  \item źródło rozwiązania początkowego dla bardziej zaawansowanych metod,
  \item szybka metoda dla dużych grafów, gdzie inne algorytmy są zbyt wolne.
\end{itemize}
Wadą algorytmu jest to, że podejmując lokalnie najlepsze decyzje, może przegapić lepsze rozwiązania globalne.

\subsection{Heurystyka zbioru dominującego}\label{subsec:ds}

Algorytm oparty na zbiorze dominującym korzysta z podejścia heurystycznego, szeroko opisywanego w literaturze w kontekście budowania maksymalnych zbiorów dominujących \cite{haynes1998domination}.
Na początku iteracyjnie wybierane są wierzchołki o najwyższej efektywności kosztowej, definiowanej jako stosunek liczby pokrywanych jeszcze węzłów do minimalnego kosztu licencji.
Tak skonstruowany zbiór dominujący pokrywa cały graf.
W naszej wersji algorytmu, rozszerzonej o obsługę różnych typów wierzchołków, po posortowaniu dominatorów według stopnia budowane są grupy obejmujące dominatora oraz jego nieprzydzielonych jeszcze sąsiadów.
Każdej grupie przypisywana jest najtańsza licencja spełniająca ograniczenia pojemnościowe, a w przypadku braku takiej - licencja indywidualna.

\begin{algorithm}[H]
  \caption{Zbiór dominujący -- heurystyka z przypisaniem grup}
  \label{alg:ds}
  \begin{algorithmic}[1]
    \Require graf $G=(V,E)$, $\mathcal{L}$
    \State $U\gets V$, $D\gets\emptyset$
    \While{$U\neq\emptyset$}
    \State dla każdego $v$ policz $\mathrm{coverage}(v)=|(N(v)\cup\{v\})\cap U|$ i $\min\_\mathrm{cpn}(v)$
    \State wybierz $u$ maksymalizujące $\mathrm{coverage}(v)/\min\_\mathrm{cpn}(v)$; jeśli nie ma, weź dowolne $u\in U$
    \State $D\gets D\cup\{u\}$, $U\gets U\setminus(N(u)\cup\{u\})$
    \EndWhile
    \State posortuj $D$ malejąco po $\deg$
    \For{każde $u\in D$ oraz dla pozostałych węzłów}
    \State $S\gets(N(u)\cup\{u\})\cap$ nieprzydzieleni
    \State wybierz najtańszą dopuszczalną grupę; w ostateczności licencję 1
    \EndFor
    \State \Return grupy
  \end{algorithmic}
\end{algorithm}

\paragraph{Złożoność i zastosowanie}
Pierwsza faza (wybór dominatorów) w każdej rundzie przechodzi po wszystkich wierzchołkach, ich sąsiadach i typach licencji, co daje koszt rzędu $O(n m T)$. Druga faza, czyli budowanie grup, dla każdego dominatora sortuje jego sąsiadów i sprawdza wszystkie warianty licencji - w gęstych grafach rośnie to do $O(n^3 T \log n)$, a w rzadkich pozostaje bliżej $O(n m T)$. Wydajność zależy więc przede wszystkim od gęstości grafu i liczby dostępnych licencji.

\subsection{Algorytm losowy}\label{subsec:random}

Algorytm losowy pełni rolę metody odniesienia, służącej do oceny jakości rozwiązań generowanych przez inne algorytmy.
Jego zadaniem jest weryfikacja poprawności - jeżeli dana metoda uzyskuje wyniki gorsze niż losowy dobór licencji i grup, świadczy to o problemie w jej implementacji lub konfiguracji.
Algorytm przetwarza wierzchołki w losowej kolejności i dla każdego z nich losowo wybiera typ licencji oraz skład grupy.
W przypadkach, gdy losowy wybór nie jest możliwy (np. brak licencji spełniającej ograniczenia), stosowana jest prosta strategia zachłanna jako rozwiązanie awaryjne.

\paragraph{Idea metody}
Algorytm działa według następującej strategii:
\begin{enumerate}
  \item Losuje kolejność przetwarzania wierzchołków.
  \item Dla bieżącego wierzchołka wyznacza zbiór kandydatów obejmujący jego i nieprzydzielonych sąsiadów.
  \item Jeżeli istnieje dopuszczalna licencja, losowo wybiera jej typ, rozmiar grupy oraz członków.
  \item W przeciwnym razie przypisuje najtańszą dostępną licencję dopuszczalną dla danego węzła.
  \item Proces powtarza się do pokrycia całego grafu; pozostałe nieprzydzielone węzły otrzymują indywidualne licencje.
\end{enumerate}


\begin{algorithm}[H]
  \caption{Losowy -- dobór licencji i składu grupy}
  \label{alg:randomized}
  \begin{algorithmic}[1]
    \Require $G=(V,E)$, $\mathcal{L}$
    \State $U\gets V$, $\pi\gets$ losowa permutacja $V$
    \For{node w kolejności $\pi$}
    \If{$node\notin U$} \textbf{continue}\EndIf
    \State $S\gets(N(node)\cup\{node\})\cap U$
    \If{istnieje dopuszczalna licencja}
    \State wylosuj $\ell$ i rozmiar $s\in[l_\ell,\min\{|S|,u_\ell\}]$, dobierz losowych członków
    \Else
    \State wybierz najtańszą dopuszczalną grupę
    \EndIf
    \State dodaj grupę, zaktualizuj $U$
    \EndFor
    \While{$U\neq\emptyset$} przypisz najtańszą licencję 1 i usuń węzeł z $U$ \EndWhile
  \end{algorithmic}
\end{algorithm}

\paragraph{Złożoność i zastosowanie}
Każdy wierzchołek i jego sąsiedzi są przeglądani co najwyżej raz, a dla każdej próby losowania licencji przechodzimy przez wszystkie typy licencji. Daje to koszt rzędu $O\bigl(T(m + n)\bigr)$, który w gęstych grafach upraszcza się do $O(T n^2)$. Algorytm służy głównie jako punkt odniesienia: pozwala szybko ocenić, czy inne metody faktycznie generują lepsze rozwiązania niż czysty przypadek.


\section{Metaheurystyki}

Metaheurystyki to zaawansowane algorytmy przeszukujące przestrzeń rozwiązań w sposób inteligentny. W przeciwieństwie do heurystyk konstrukcyjnych, które budują rozwiązanie od zera, metaheurystyki zaczynają od pewnego rozwiązania i systematycznie je poprawiają.

\paragraph{Dobór parametrów}
Parametry metaheurystyk zostały dobrane eksperymentalnie na podstawie testów na grafach różnych rozmiarów.

\paragraph{Operacje modyfikacji rozwiązania}
Metaheurystyki poprawiają rozwiązanie stosując następujące operacje:
\begin{itemize}
  \item zmiana typu licencji używanej przez właściciela grupy
  \item przeniesienie członka z jednej grupy do drugiej
  \item zamiana miejscami dwóch członków z różnych grup
  \item scal dwie grupy w jedną lub rozdziel na dwie dopuszczalne.
\end{itemize}

\subsection{Algorytm genetyczny}\label{subsec:ga}
Algorytm genetyczny utrzymuje populację pełnych przydziałów licencyjnych i z pokolenia na pokolenie ulepsza je, korzystając z losowych mutacji i krzyżowania par rodziców \cite{holland1975,goldberg1989}. Zaczyna od mieszanki rozwiązań zachłannych i losowych, a następnie w każdej generacji wybiera najlepsze osobniki (elita), losuje rodziców metodą turniejową i tworzy potomstwo przez krzyżowanie lub mutację. Słabsze rozwiązania są stopniowo zastępowane lepszymi, a algorytm zapamiętuje najlepszy znaleziony koszt.

\paragraph{Parametry}
\begin{itemize}
  \item \textbf{Wielkość populacji} $P=30$ - liczba rozwiązań utrzymywanych w każdej generacji.
  \item \textbf{Liczba pokoleń} $G=40$ - maksymalna liczba iteracji ewolucji.
  \item \textbf{Udział elity} $\alpha=20\%$ - część najlepszych osobników kopiowana bez zmian do kolejnego pokolenia.
  \item \textbf{Prawdopodobieństwo krzyżowania} $p_c=60\%$ - przy tej szansie dziecko powstaje przez połączenie dwóch rodziców; w przeciwnym razie wykonywana jest mutacja.
\end{itemize}

\begin{algorithm}[H]
  \caption{Algorytm genetyczny}
  \label{alg:ga}
  \begin{algorithmic}[1]
    \Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
    \State utwórz populację początkową (zachłanny + losowe rozwiązania)
    \For{każde pokolenie}
    \State oceń wszystkie rozwiązania (funkcja kosztu)
    \State zachowaj elitę (najlepsze rozwiązania)
    \While{populacja niepełna}
    \If{losowanie krzyżowania}
    \State wybierz dwóch rodziców (selekcja turniejowa)
    \State skrzyżuj rodziców (połącz efektywne grupy)
    \Else
    \State wybierz rozwiązanie i zmutuj (operacje sąsiedztwa)
    \EndIf
    \State dodaj potomka do nowej populacji
    \EndWhile
    \State zaktualizuj najlepsze znalezione rozwiązanie
    \EndFor
    \State \Return najlepsze rozwiązanie
  \end{algorithmic}
\end{algorithm}

\paragraph{Złożoność i zastosowanie}
Inicjalizacja populacji korzysta z jednej wersji zachłannej i $P$ losowych rozwiązań, co kosztuje około $O\bigl(P \cdot (nT + m\log n)\bigr)$. Każda generacja sortuje populację ($O(P\log P)$), a następnie tworzy nowych potomków. Mutacje wywołują ograniczoną liczbę operatorów sąsiedztwa, a krzyżowanie w razie potrzeby uruchamia heurystykę zachłanną na podgrafie, co razem daje koszt rzędu $O(nT + m\log n)$ na potomka. Łącznie otrzymujemy $O\bigl(G \cdot P \cdot (nT + m\log n)\bigr)$ w najgorszym przypadku. Algorytm działa wolniej od prostych heurystyk, ale potrafi znacząco poprawić ich wyniki i służy jako główna metoda poszukiwania wysokiej jakości rozwiązań, zwłaszcza gdy mamy czas na dłuższą optymalizację.



\subsection{Przeszukiwanie tabu}\label{subsec:tabu}
Algorytm tabu startuje od rozwiązania zachłannego i w każdej iteracji generuje niewielkie sąsiedztwo kandydatów przy pomocy operatorów mutacji. Spośród poprawnych kandydatów wybierany jest najlepszy, o ile jego sygnatura nie znajduje się na liście tabu. Lista tabu blokuje cofanie ostatnich ruchów, a kryterium aspiracji pozwala ją złamać, gdy kandydat poprawia globalny wynik \cite{glover1989}. Dzięki temu algorytm balansuje między lokalnym doskonaleniem a eksploracją nowych przydziałów licencji.

\paragraph{Parametry}
\begin{itemize}
  \item \textbf{Maksymalna liczba iteracji} $I=1000$ - liczba prób poprawienia rozwiązania.
  \item \textbf{Długość listy tabu} $L=20$ - liczba ostatnich ruchów blokowanych przed ponownym użyciem.
  \item \textbf{Liczba sąsiadów na iterację} $k=10$ - liczba kandydatów generowanych przed wyborem najlepszego.
\end{itemize}

\begin{algorithm}[H]
  \caption{Przeszukiwanie tabu}
  \label{alg:tabu}
  \begin{algorithmic}[1]
    \Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
    \State $aktualne \gets$ rozwiązanie początkowe (zachłanne)
    \State $najlepsze \gets aktualne$
    \State $lista\_tabu \gets$ pusta lista o stałej długości
    \For{każdą iterację}
    \State wygeneruj sąsiadów $aktualne$ (zmiana licencji, przeniesienie członka, itp.)
    \State wybierz najlepszego sąsiada spośród tych, które nie są na liście tabu lub poprawiają dotychczasowe $najlepsze$ (aspiracja)
    \If{znaleziono kandydata}
    \State $aktualne \gets$ wybrany kandydat
    \State dodaj ruch do $lista\_tabu$
    \If{$aktualne$ lepsze niż $najlepsze$}
    \State $najlepsze \gets aktualne$
    \EndIf
    \EndIf
    \EndFor
    \State \Return $najlepsze$
  \end{algorithmic}
\end{algorithm}

\paragraph{Złożoność i zastosowanie}
Rozruch algorytmu obejmuje pojedyncze wywołanie heurystyki zachłannej $O(nT + m\log n)$. W każdej z $I$ iteracji generowanych jest do $k$ sąsiadów, a każdy kandydat przechodzi walidację obejmującą sprawdzenie pojemności, pokrycia i sąsiedztwa, co kosztuje około $O(nT + m)$. Całość prowadzi do kosztu rzędu $O\bigl(I \cdot k \cdot (nT + m)\bigr)$. Przeszukiwanie tabu dobrze sprawdza się jako metoda doszkalająca: potrafi poprawić rozwiązania bazowe przy umiarkowanym czasie obliczeń i jest odporne na zbieganie w krótkie cykle dzięki liście tabu.


\subsection{Algorytm mrówkowy}\label{subsec:aco}
Algorytm mrówkowy buduje wiele rozwiązań równolegle. Każda mrówka konstruuje przydział licencji, kierując się siłą śladów feromonowych (informacja o dotychczas dobrych wyborach) oraz heurystyką preferującą wierzchołki o dużym stopniu i licencje o dobrym stosunku pojemności do ceny \cite{dorigo1997}. Po każdej iteracji feromony parują, a najlepsze dotąd rozwiązanie wzmacnia ścieżki, dzięki czemu kolejne mrówki chętniej eksplorują obiecujące fragmenty przestrzeni.

\paragraph{Parametry}
\begin{itemize}
  \item \textbf{Waga feromonu} $\alpha=1.0$ -- określa, jak mocno mrówki ufają dotychczasowym śladom.
  \item \textbf{Waga heurystyki} $\beta=2.0$ -- wzmacnia preferencję dla lokalnie dobrych decyzji (wysoki stopień, tanie licencje).
  \item \textbf{Tempo parowania} $\rho=0.5$ -- część feromonu usuwana po każdej iteracji.
  \item \textbf{Prawdopodobieństwo wyboru zachłannego} $q_0=0.9$ -- z tą szansą mrówka wybiera najlepszą dostępnie opcję, w przeciwnym razie losuje proporcjonalnie do wag.
  \item \textbf{Liczba mrówek} $A=20$ -- ile rozwiązań konstruujemy równolegle w jednej iteracji.
  \item \textbf{Maksymalna liczba iteracji} $I=100$ -- ile razy aktualizujemy feromony.
  \item \textbf{Losowe nasiono} (opcjonalne) -- pozwala odtworzyć przebieg eksperymentu.
\end{itemize}

\begin{algorithm}[H]
  \caption{Algorytm mrówkowy}
  \label{alg:aco}
  \begin{algorithmic}[1]
    \Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
    \State zainicjalizuj feromony $\tau$ (dla par wierzchołek-licencja)
    \State zainicjalizuj heurystyki $\eta$ (na podstawie stopni wierzchołków i kosztów licencji)
    \State $najlepsze \gets$ rozwiązanie początkowe (zachłanne)
    \For{każdą iterację}
    \For{każdą mrówkę}
    \State $niepokryte \gets V$
    \While{$niepokryte \neq \emptyset$}
    \State wybierz właściciela na podstawie $\tau$ i $\eta$ (reguła wyboru lub ruletka)
    \State wybierz typ licencji na podstawie $\tau$ i $\eta$
    \State utwórz grupę, usuń członków z $niepokryte$
    \EndWhile
    \If{mrówka znalazła lepsze rozwiązanie}
    \State $najlepsze \gets$ rozwiązanie mrówki
    \EndIf
    \EndFor
    \State wyparuj część feromonów: $\tau \gets \tau \cdot (1-evaporation)$
    \State wzmocnij feromony na ścieżce $najlepsze$: $\tau \gets \tau + 1/koszt$
    \EndFor
    \State \Return $najlepsze$
  \end{algorithmic}
\end{algorithm}

\paragraph{Złożoność i zastosowanie}
Inicjalizacja feromonów i heurystyk kosztuje $O(nT)$. Pojedyncza konstrukcja rozwiązania przez mrówkę odwiedza każdy wierzchołek co najwyżej raz, ale przy wyborze właściciela ponownie ocenia wszystkich kandydatów i wszystkie licencje; prowadzi to do kosztu około $O(n^2 T + m\log n)$ na jedną mrówkę (uwzględniając sortowanie sąsiadów). Cały algorytm wykonujący $I$ iteracji z $A$ mrówkami ma więc koszt rzędu $O\bigl(I \cdot A \cdot (n^2 T + m\log n)\bigr)$. Metoda jest cięższa obliczeniowo niż tabu czy zachłanny, ale dobrze sprawdza się, gdy chcemy eksplorować wiele alternatywnych konfiguracji i stopniowo wzmacniać najlepsze z nich.

\subsection{Symulowane wyżarzanie }\label{subsec:sa}
Symulowane wyżarzanie rozpoczyna od rozwiązania zachłannego i w każdej iteracji losuje ruch sąsiedztwa (zmiana licencji, przeniesienie członka, zamiana, scalenie lub podział grupy). Nowy stan jest akceptowany zawsze, gdy obniża koszt, a czasami także wtedy, gdy go pogarsza - z prawdopodobieństwem zależnym od bieżącej temperatury \(T\) i różnicy kosztów \cite{kirkpatrick1983}. Temperatura maleje według ustalonego współczynnika, a gdy algorytm zbyt długo nie znajduje poprawy, dodatkowo jest obniżana o połowę. Dzięki temu metoda potrafi opuszczać lokalne minima i stopniowo stabilizuje się w pobliżu dobrego rozwiązania.

\paragraph{Parametry}
\begin{itemize}
  \item \textbf{Temperatura początkowa} $T_0 = 100.0$ - początkowy poziom losowości przy akceptacji gorszych ruchów.
  \item \textbf{Współczynnik chłodzenia} $\alpha = 0.995$ - w każdej iteracji temperatura jest mnożona przez $\alpha$.
  \item \textbf{Temperatura minimalna} $T_{\min} = 0.001$ - po jej osiągnięciu algorytm kończy działanie.
  \item \textbf{Maksymalna liczba iteracji} $I = 20\,000$ - górne ograniczenie liczby kroków.
  \item \textbf{Limit stagnacji} $S = 2\,000$ - po tylu nieudanych próbach temperatura jest dodatkowo dzielona przez 2.
\end{itemize}

\begin{algorithm}[H]
  \caption{Symulowane wyżarzanie}
  \label{alg:sa}
  \begin{algorithmic}[1]
    \Require graf $G=(V,E)$, typy licencji $\mathcal{L}$
    \State $aktualne \gets$ rozwiązanie początkowe (zachłanne)
    \State $najlepsze \gets aktualne$
    \State $temperatura \gets T_0$ (początkowa temperatura)
    \For{każdą iterację}
    \If{$temperatura < T_{min}$} \textbf{break} \EndIf
    \State wybierz losową operację sąsiedztwa
    \State $kandydat \gets$ wynik operacji sąsiedztwa
    \State $\Delta \gets koszt(kandydat) - koszt(aktualne)$
    \If{$\Delta \leq 0$ LUB $random() < \exp(-\Delta / temperatura)$}
    \State $aktualne \gets kandydat$
    \If{$koszt(kandydat) < koszt(najlepsze)$}
    \State $najlepsze \gets kandydat$
    \EndIf
    \EndIf
    \State $temperatura \gets temperatura \cdot cooling\_rate$
    \EndFor
    \State \Return $najlepsze$
  \end{algorithmic}
\end{algorithm}

\paragraph{Złożoność i zastosowanie}
Inicjalizacja wymaga jednego wywołania heurystyki zachłannej $O(nT + m\log n)$. Każda iteracja wykonuje ograniczoną liczbę prób wygenerowania sąsiada (do 12 ruchów), a zaakceptowany kandydat przechodzi pełną walidację pokrycia i ograniczeń, co kosztuje około $O(nT + m)$. W rezultacie złożoność całego przebiegu wynosi $O\bigl(I \cdot (nT + m)\bigr)$ z dodatkowym mnożnikiem wynikającym z limitu stagnacji. Symulowane wyżarzanie jest umiarkowanie kosztowne, ale często zapewnia lepsze rozwiązania niż czyste metody lokalne, szczególnie gdy potrzebna jest możliwość wychodzenia z lokalnych minimów przy ograniczonym czasie działania.
